# Архитектура системы логирования и уведомлений через WebSocket

Эта система предназначена для передачи двух типов информации с бэкенда на фронтенд в реальном времени:
1.  **Потоковые логи**: Текстовые сообщения, информирующие о ходе выполнения длительной операции (например, парсинга).
2.  **Уведомления**: Структурированные сообщения о результате выполнения операции (успех или ошибка).

## 1. Бэкенд: Отправка сообщений

Отправка сообщений инкапсулирована в приложении `web_logger`. Существует два способа отправки, в зависимости от контекста выполнения кода.

### Из синхронного кода (например, `kinozal_scan/parse.py`)

-   **Функция**: `log(message: str, logger_name: LogType)`
-   **Как работает**: Используется для отправки простых текстовых логов из синхронных функций, которые выполняются в отдельном потоке (через `run_in_executor`).
-   **Механизм**: Внутри `log` вызывается `send_log_to_websocket`, которая использует `asgiref.sync.async_to_sync` для "проброса" сообщения из синхронного потока в асинхронный event loop Django Channels.
-   **Тип события Channels**: `send_log_update`

### Из асинхронного кода (например, `kinozal_scan/service.py`)

-   **Функции**: `alog(message: str, logger_name: LogType)` и `asend_notification(payload: dict)`
-   **Как работает**: Используются для отправки логов и структурированных уведомлений напрямую из `async` функций (например, из `runner` в `service.py`).
-   **Механизм**: Эти функции являются нативными `async` функциями и используют `await` для отправки сообщений в канал без блокировок.
-   **Типы событий Channels**: `send_log_update` для `alog` и `send_notification` для `asend_notification`.

## 2. Бэкенд: Consumer (`web_logger/websocket_consumers.py`)

-   **Класс**: `LogConsumer`
-   **Группа Channels**: `log_updates` (все клиенты подписываются на эту группу при подключении).
-   **Обработчики**:
    -   `send_log_update(self, event)`: Срабатывает на событие от `log` или `alog`. Получает текстовое сообщение, "заворачивает" его в стандартный формат `{'type': 'log', 'content': ...}` и отправляет клиенту.
    -   `send_notification(self, event)`: Срабатывает на событие от `asend_notification`. Получает готовый словарь (`payload`) и пересылает его клиенту без изменений.

## 3. Фронтенд (`kinozal_scan/templates/scan_page.html`)

-   **Подключение**: При загрузке страницы устанавливается одно WebSocket соединение.
-   **Обработчик `socket.onmessage`**:
    1.  Получает данные от сервера и парсит их как JSON (`const data = JSON.parse(event.data);`).
    2.  Проверяет поле `data.type`.
    3.  **Если `data.type === 'log'`**:
        -   Создаёт новый `<div>` для записи лога.
        -   Фильтрует сообщение на основе выбранного radio-button (Scan, Debug, Error).
        -   Добавляет `div` в контейнер `#log-content`.
    4.  **Если `data.type === 'scan_complete'`**:
        -   Вызывает функцию `showToast(data.message, data.status)` для отображения всплывающего уведомления.
        -   Выполняет дополнительные действия (например, скрывает кнопку "Cancel").
